# Agenda

### Introduction

* Historical overview
* Imperative and decalarative programming
* Complexity
* The perils of mutable state
* Static and dynamic typing
* Abstraction
* Data representation
* Composition

### Functions

* Relations vs. functions
* Introduction to Lambda calculus
* Binding and environments
* Pure functions: Expressions and statements
* Referential transparency
* Composition
* Higher-order functions
* Currying and partial application
* Recursion and tail call optimization

### Introduction to F\# on .NET Core

* Order of declarations and files
* Mutual recursion: types, functions and modules
* Pattern matching
* Active patterns
* Mutable variables

### Types and type systems

* Introduction to types
* Type systems and type checking
* Type inference
* The Curry-Howard isomorphism
  * Existence as proof
* Algebraic data types
* OOP features

### Patterns and abstraction

* Functors
* Applicative functors
* Monads
* Optics

### Generic programming in F\#

* Types, classes and members
* Interfaces
* Constraints

### Designing with types

* Stating intent
* Domain modeling
* Algebraic types as conjunction and disjunction
* Making invalid state unrepresentable

### Domain Specific Languages

* Combinators
* HTML combinators

### Reactive programming

* Fable React
* Fable Elmish
